<!DOCTYPE html>
<html>

<head>
  <!-- Compiled and minified CSS -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/materialize/1.0.0/css/materialize.min.css">
  <!-- Compiled and minified JavaScript -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/materialize/1.0.0/js/materialize.min.js"></script>
  <!--Import Google Icon Font-->
  <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
  <!--Import materialize.css-->
  <link type="text/css" rel="stylesheet" href="css/materialize.min.css" media="screen,projection" />
  <!--JQuery-->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.2.1/jquery.min.js"></script>
  <link rel="stylesheet" href="/style.css">
  <!--Let browser know website is optimized for mobile-->
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />


</head>

</head>

<body>
  <!--Nav Bar-->
  <nav class="nav-extended blue lighten-2">
    <div class="nav-wrapper">
      <a style="padding: 10px;" href="/index.html" class="brand-logo">
        <img src="../../src/svg/logo.svg" alt="Logo Site">
      </a>

    </div>
    <div class="nav-content">
      <ul class="tabs tabs-transparent">
        <li class="tab valign-wrapper center-align">
          <a href="/index.html" class="active waves-effect waves-light valign-wrapper center-align">
            Página Inicial
            <i class="material-icons left">home</i>
          </a>
        </li>

      </ul>
    </div>
  </nav>
  <!--Nav Bar-->

  <div class="section">
    <h4> Navegação entre telas em um aplicativo Flutter</h4>
    <div class="row">
      <div class="col s6"><span class="flow-text"></span>
        <p>No Flutter, existem vários métodos para navegar entre telas em um aplicativo.<br> Há
          dois dos métodos mais comuns: uso do widget Navigator e uso de rotas nomeadas.
        </p>
      </div>
    </div>
    <ul class="collapsible">
      <li>
        <div class="collapsible-header">Widget Navigator</div>
        <div class="collapsible-body"><span> O Flutter fornece o widget Navigator para gerenciar a pilha de telas (ou rotas) em um
          aplicativo. Você pode usar o Navigator para empilhar uma nova tela na parte superior da
          pilha, empurrando-a para a frente, ou para remover uma tela da pilha, empurrando-a para
          trás.
          <div class="row">
            Para navegar para uma nova tela usando o Navigator, você normalmente precisa executar
            as seguintes etapas:
          </div>
          <div class="row">
            ● Importe o pacote do Flutter:
            <br>
            <img src="../../src/images/semana05-img01.png">
            <br>
            ● Crie uma função para lidar com a navegação:
            <br>
            <img src="../../src/images/semana05-img02.png">
            <br>
            ● Chame a função de navegação em resposta a um evento, como um botão pressionado:
            <br>
            <img src="../../src/images/semana05-img03.png">
            <br>
            No exemplo acima, NewScreen() representa a tela para a qual você deseja navegar. Ao
            chamar Navigator.push, você está adicionando uma nova rota à pilha e a tela será
            empurrada para a frente.
          </div>
        </div>
      </li>
      <li>
        <div class="collapsible-header">Rotas nomeadas</div>
        <div class="collapsible-body">
          <div class="row">
            <div class="col s6"><span> O uso de rotas nomeadas fornece uma maneira mais estruturada de navegar entre telas,
              permitindo que você defina um nome para cada rota e navegue para ela usando esse nome.
              Isso torna o código mais organizado e facilita a manutenção.
              <br>
              ● Declare as rotas nomeadas no método MaterialApp ou CupertinoApp:
              <br>
              <img src="../../src/images/semana05-img04.png">
              <br>
              ● Navegue para uma nova tela usando o nome da rota:
              <br>
              <img src="../../src/images/semana05-img05.png">
              <br>
              É importante observar que, se você deseja passar dados para a nova tela ou retornar dados
              da nova tela para a tela anterior, o Flutter fornece mecanismos adicionais, como
              argumentos de rota e retornos de tela. Esses recursos podem ser usados em conjunto com
              os métodos de navegação mencionados acima.
            </span>
            </div>
          </div>
        </div>
      </li>
    </ul>
  </div>
  <div class="divider"></div>
  <div class="section">
    <h4>Gerenciamento de estado em um aplicativo Flutter</h4>
    <div class="row">
      <div class="col s6"><span class="flow-text"> </span>
        <p>
          No desenvolvimento de aplicativos Flutter, o gerenciamento de estado é uma parte
          fundamental para manter a consistência e a sincronização dos dados entre os diferentes
          componentes da interface do usuário. Existem várias abordagens para o gerenciamento de
          estado em Flutter, incluindo o uso de bibliotecas externas, como o Provider, MobX, Redux,
          entre outras. Além disso, o próprio Flutter possui um mecanismo interno chamado
          "gerenciamento de estado local" que permite controlar o estado em um único widget.
        </p>
        <p>
          <b>Gerenciamento de estado local (Stateful Widgets) </b>: Use widgets stateful para controlar o
          estado dentro de um único widget. É adequado para aplicativos menores ou com requisitos
          de estado simples.
        </p>
        <p>
          <b>Provider:</b> Uma biblioteca popular que permite compartilhar estado eficientemente entre
          widgets, seguindo o conceito de Injeção de Dependência. É útil para atualizar dados de
          forma reativa.
        </p>
        <p>
          <b>MobX:</b> Uma biblioteca poderosa que usa observáveis e reações para rastrear dependências
          entre os dados e atualizar automaticamente a interface do usuário. É útil para gerenciar
          estados complexos ou reativos.
        </p>
        <p>
          <b>Redux:</b> Uma arquitetura de gerenciamento de estado que usa um store centralizado para
          armazenar todo o estado do aplicativo e implementar um fluxo unidirecional para atualizar e
          recuperar dados, adequado para aplicativos com grande quantidade de estado
          compartilhado.
        </p>
        <p>
          Essas são algumas das opções disponíveis, e a escolha depende do tamanho,
          complexidade e necessidades do seu aplicativo. É recomendável experimentar diferentes
          abordagens para encontrar a que melhor se adapte ao seu projeto.
        </p>
      </div>
    </div>
  </div>
  <div class="divider"></div>
  <div class="section">
    <h5>Section 3</h5>
    <p>Stuff</p>
  </div>
  <!--Nav Bar-->

  <!--Nav Bar-->



  <!--Footer-->
  <footer class="page-footer">
    <div class="container">
      <div class="row">
        <div class="col l6 s12">
          <h5 class="white-text">Footer Content</h5>
          <p class="grey-text text-lighten-4">You can use rows and columns here to organize your footer content.</p>
        </div>
        <div class="col l4 offset-l2 s12">
          <h5 class="white-text">Links</h5>
          <ul>
            <li><a class="grey-text text-lighten-3" href="#!">Link 1</a></li>
            <li><a class="grey-text text-lighten-3" href="#!">Link 2</a></li>
            <li><a class="grey-text text-lighten-3" href="#!">Link 3</a></li>
            <li><a class="grey-text text-lighten-3" href="#!">Link 4</a></li>
          </ul>
        </div>
      </div>
    </div>


    <div class="footer-copyright">
      <div class="container">
        © 2014 Copyright Text
        <a class="grey-text text-lighten-4 right" href="#!">More Links</a>
      </div>
    </div>
  </footer>

  <!--Footer-->


  <script src="../../javascript/materialize.js"></script>
</body>

</html>